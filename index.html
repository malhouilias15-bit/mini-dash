<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Mini Dash</title>
<style>
html,body{margin:0;padding:0;background:#0b0f1a;color:white;font-family:Arial;overflow:hidden}
canvas{display:block;margin:auto}
button{background:#1e2a44;color:white;border:1px solid #3af;padding:6px 10px;margin:4px;border-radius:6px;cursor:pointer}
#menu,#editorUI,#hud,#complete{position:absolute;left:0;right:0;text-align:center}
#menu{top:40px}
#editorUI{top:10px;left:10px;text-align:left}
#hud{top:10px}
#complete{top:200px;font-size:40px;display:none}
</style>
</head>
<body>

<div id="menu">
<h1>MINI DASH</h1>
<div id="levels"></div><br>
<button onclick="startEditor()">Level Editor</button>
</div>

<div id="editorUI" style="display:none">
<b>EDITOR</b><br>
<button onclick="tool='block'">Block</button>
<button onclick="tool='spike'">Spike</button>
<button onclick="tool='pad'">Jump Pad</button>
<button onclick="tool='portalBlue'">Blue Portal</button>
<button onclick="tool='portalGreen'">Green Portal</button>
<button onclick="tool='erase'">Erase</button><br><br>
<button onclick="playCustom()">Play Custom</button>
</div>

<div id="hud"></div>
<div id="complete">LEVEL COMPLETE!</div>
<canvas id="game" width="1000" height="450"></canvas>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");

let mode="menu",tool="block",levelIndex=0;
let scroll=0,speed=4,levelEnd=8000;
let completed=false;

const player={x:150,y:300,v:0,size:26,grounded:false,ship:false};

const levels=[
 {name:"Neon Warmup",data:[]},
 {name:"Pulse Runner",data:[]},
 {name:"Quantum Hop",data:[]},
 {name:"Chromatic Caverns",data:[]},
 {name:"Drift Zone",data:[]}
];

function genLevel(seed){
 let arr=[],x=300;
 for(;x<levelEnd;x+=120){
  arr.push({x,y:360,w:120,h:20,type:"block"});
  if(Math.random()<0.4) arr.push({x:x+40,y:330,w:40,h:30,type:"spike"});
  if(Math.random()<0.25) arr.push({x:x+50,y:300,w:30,h:20,type:"pad"});
  if(Math.random()<0.15) arr.push({x,y:260,w:30,h:30,type:"portalBlue"});
  if(Math.random()<0.15) arr.push({x,y:260,w:30,h:30,type:"portalGreen"});
 }
 return arr;
}

levels.forEach((l,i)=>l.data=genLevel(i));

function addButtons(){
 const div=document.getElementById("levels");
 levels.forEach((l,i)=>{
  const b=document.createElement("button");
  b.innerText=l.name;
  b.onclick=()=>startLevel(i);
  div.appendChild(b);
 });
}
addButtons();

function startLevel(i){
 levelIndex=i;
 reset();
 mode="play";
 document.getElementById("menu").style.display="none";
}

function startEditor(){
 reset();
 mode="editor";
 document.getElementById("menu").style.display="none";
 document.getElementById("editorUI").style.display="block";
}

function playCustom(){
 reset();
 mode="play";
 document.getElementById("editorUI").style.display="none";
}

function reset(){
 scroll=0;
 completed=false;
 player.y=300;
 player.v=0;
 player.ship=false;
 document.getElementById("complete").style.display="none";
}

document.addEventListener("keydown",e=>{
 if(e.code==="Space" && mode==="play"){
  if(player.ship) player.v=-6;
  else if(player.grounded){
   player.v=-13;
   player.grounded=false;
  }
 }
});

canvas.addEventListener("mousedown",e=>{
 if(mode!=="editor") return;
 const x=e.offsetX+scroll,y=e.offsetY;
 const arr=levels[levelIndex].data;
 if(tool==="erase"){
  levels[levelIndex].data=arr.filter(o=>!(x>o.x&&x<o.x+o.w&&y>o.y&&y<o.y+o.h));
 }else{
  arr.push({x,y,w:40,h:40,type:tool});
 }
});

function update(){
 ctx.fillStyle="#1b2b5f";
 ctx.fillRect(0,0,canvas.width,canvas.height);

 if(mode==="play" && !completed){
  player.v+=player.ship?0.35:0.7;
  player.y+=player.v;
  scroll+=speed;
 }

 if(player.y+player.size>360){
  player.y=360-player.size;
  player.v=0;
  player.grounded=true;
 }

 const data=levels[levelIndex].data;
 data.forEach(o=>{
  const dx=o.x-scroll;

  if(o.type==="block"){
   ctx.strokeStyle="#3af";
   ctx.strokeRect(dx,o.y,o.w,o.h);
   if(hit(o)&&player.v>=0){
    player.y=o.y-player.size;
    player.v=0;player.grounded=true;
   }
  }

  if(o.type==="spike"){
   ctx.fillStyle="#8ff";
   ctx.beginPath();
   ctx.moveTo(dx,o.y+o.h);
   ctx.lineTo(dx+o.w/2,o.y);
   ctx.lineTo(dx+o.w,o.y+o.h);
   ctx.fill();
   if(hit(o)) reset();
  }

  if(o.type==="pad"){
   ctx.fillStyle="yellow";
   ctx.fillRect(dx,o.y,o.w,o.h);
   if(hit(o)) player.v=-18;
  }

  if(o.type==="portalBlue" && hit(o)) player.ship=true;
  if(o.type==="portalGreen" && hit(o)) player.ship=false;
 });

 if(scroll>=levelEnd && !completed){
  completed=true;
  document.getElementById("complete").style.display="block";
  setTimeout(()=>{
   mode="menu";
   document.getElementById("menu").style.display="block";
  },2000);
 }

 if(mode==="play") drawPlayer();

 document.getElementById("hud").innerText=
 `${Math.min(100,Math.floor(scroll/levelEnd*100))}%`;

 requestAnimationFrame(update);
}

function hit(o){
 return player.x<o.x+o.w-scroll &&
        player.x+player.size>o.x-scroll &&
        player.y<o.y+o.h &&
        player.y+player.size>o.y;
}

function drawPlayer(){
 ctx.save();
 ctx.translate(player.x+13,player.y+13);
 ctx.rotate(Math.PI/4);
 ctx.fillStyle="#6cf";
 ctx.fillRect(-13,-13,26,26);
 ctx.restore();
}

update();
</script>
</body>
</html>
